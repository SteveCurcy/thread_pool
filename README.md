# thread_pool
[![](https://img.shields.io/badge/Author-Xu.Cao-lightgreen)](https://github.com/SteveCurcy) ![](https://img.shields.io/badge/Version-1.1.3-yellow)

基于 C++ 实现的线程池，简单但高效。（仅 556 行代码）

## 内容列表

- [1. 背景 :cookie:](#1-背景-cookie)
- [2. 解决方案 :candy:](#2-解决方案-candy)
- [3. 安装和运行 :birthday:](#3-安装和运行-birthday)
- [4. 现有问题 :sandwich:](#4-现有问题-sandwich)
- [5. 使用许可 :page_facing_up:](#5-使用许可-page_facing_up)

## 1. 背景 :cookie:
本项目主要想要完成一个开箱即用的线程池库，在尽可能简单易用、方便定制的情况下实现高性能线程池。

## 2. 解决方案 :candy:
本项目目前主要提供了以下特性：

- 无锁化：在 v0.xx 版本中，所有队列都使用 STL 容器实现，使用自行实现的自旋锁实现不同线程之间的互斥访问，但是这也使得线程的访问存在瓶颈：所有线程在同一时刻只能有一个线程访问同一个队列；在 v1.xx 版本中，队列的默认实现为无锁队列，这使得同一时刻可以存在多个线程访问同一个队列，从而突破了加锁带来的性能瓶颈。此外，本项目的无锁队列还实现了批量化的添加和删除，本特性将预计在之后的版本中完成实际应用。
- 简单化管理：在 v0.xx 版本中，有一个管理线程完成对所有其他线程的管理，包含对任务的分配，任务时长的计算等，这些都为线程管理带来了不小的开销；因此在 v1.xx 版本中，将不再使用单独管理线程来进行任务和线程的管理，而是使用任务获取策略来控制，即利用是否能获取到任务来控制线程的生命周期。目前核心线程和普通线程的优先级是相同的，即不管何时他们都能获取到任务并执行，但是在后续的版本中，应该根据是否为核心线程来完成任务分配，如：当任务只有核心线程就可以处理时，普通线程获取不到任务而核心线程可以，这样就可以通过任务的获取来控制线程的生命周期。在获取不到任务一定次数后，线程将自行销毁，这样就可以自然地完成线程的管理并且只需要很小的管理开销。

## 3. 安装和运行 :birthday:

C++ Build

```
mkdir build && cd build
cmake ..
make
ctest
```

## 4. 现有问题 :sandwich:
可能存在少量任务丢失，原因未知。

## 5. 使用许可 :page_facing_up:
[GPL 2.0](./LICENSE) &copy; Xu.Cao (Steve Curcy)
