# thread_pool
[![](https://img.shields.io/badge/Author-Xu.Cao-lightgreen)](https://github.com/SteveCurcy) ![](https://img.shields.io/badge/Version-0.0.3-yellow)

基于 C++ 实现的线程池，简单但高效。本项目还给出了一个网络中的简易线程池，它实现的工作线程之间通过互斥锁来争抢任务，但是存在线程池结束后任务丢失的情况，本项目对其进行了简单的修改，目前可能存在其他竞争问题。

## 内容列表

- [1. 背景 :cookie:](#1-背景-cookie)
- [2. 问题 :cake:](#2-问题-cake)
- [3. 解决方案 :candy:](#3-解决方案-candy)
- [4. 安装和运行 :birthday:](#4-安装和运行-birthday)
- [5. 现有问题 :sandwich:](#5-现有问题-sandwich)
- [6. 使用许可 :page_facing_up:](#6-使用许可-page_facing_up)

本项目提供了两个线程池代码，分别为 `thread_pool` 和 `ThreadPool`，其中前者是作者根据网络资源整理并编写的优化后的线程池代码，现在仍有诸多不足，比如当前只实现了核心线程，还没有引入辅助线程；后者是网络资源中的一个简单线程池的实现，但由于存在任务丢失的问题，作者对其进行了微小的修改，以保证其不会出现任务丢失，但是可能引入了其他的竞争问题。

## 1. 背景 :cookie:
多线程是操作系统的一个重要的特性，它频繁出现在各项任务和业务中，但是频繁的线程创建和销毁将带来大量的线程调度带来的时间损耗，因此出现了线程池。最简单的线程池就是创建多个工作线程，持续争抢任务队列中的任务，来异步完成提交的各项任务。

## 2. 问题 :cake:
但是，最简易的线程池虽然省去了线程创建和销毁的时间代价，但是也引入了任务争抢带来的加锁解锁、等待唤醒之类的时间损耗。因此，线程池的优化也是一个十分重要的问题。

## 3. 解决方案 :candy:
本项目目前主要针对该问题实施了三种优化方式，分别如下：

- 提高线程的扇入和扇出：由于单个任务执行可能带来大量的资源争抢问题，那么我们可以考虑，每次让线程批量执行一部分任务，从而减少对任务的争抢带来的加锁解锁、等待唤醒的耗时。这样，我们可以灵活地在任务量激增的情况下将线程转换为批量执行模式，从而提高线程池的执行效率。
- 线程本地队列：在 C++11 之后，引入了 `thread_local` 线程本地变量的概念。因此，我们可以为每一个核心线程配备一个本地的任务队列缓存，其中的任务由线程池进行统一分配，防止出现任务分配不均的问题。此后，核心线程只需要访问当前的任务缓存，而不需与其他线程争抢线程池的唯一任务队列，从而尽可能减少资源争抢的耗时。
- 任务窃取：假设我们有 10 个任务，但是由于一个意外被全部分配给第一个核心线程，这样会导致线程池退化为单线程。因此，当一个线程完成本地任务缓存后，也要检查是否其他核心线程还有未完成的任务，来帮助其完成任务，使得任务执行时间得到均摊，进一步减少任务执行的耗时。

此外，我们除了使用这三种优化方案，还自行实现了自旋锁。自旋锁不会导致线程挂起或唤醒，也不会导致上下文的切换和系统调度，而是采用轮询的方式来检查是否可以上锁。这样在资源访问时间较短、冲突较少（上述三个优化方案减少冲突）的情况下，可以极大地节省由于上锁和解锁带来的时间损耗。

## 4. 安装和运行 :birthday:

本项目无需安装，只需编译运行。作者的 IDE 是 Clion，但是无论使用什么 IDE，只要在代码中引用了 `thread_pool` 头文件，都可以轻松的使用本代码。本项目提供了一个 `main.cpp`，其中提供了两种线程池实现的性能测试，您可以直接运行尝试，

## 5. 现有问题 :sandwich:
如果发现程序 1s 内没显示结果，则可以重新运行。由于目前，简易版线程池可能存在未知资源竞争，因此可能出现死锁的情况。

## 6. 使用许可 :page_facing_up:
[GPL 2.0](./LICENSE) &copy; Xu.Cao (Steve Curcy)
