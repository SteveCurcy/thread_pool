# thread_pool
[![](https://img.shields.io/badge/Author-Xu.Cao-lightgreen)](https://github.com/SteveCurcy) ![](https://img.shields.io/badge/Version-0.0.4-yellow)

基于 C++ 实现的线程池，简单但高效。

## 内容列表

- [1. 背景 :cookie:](#1-背景-cookie)
- [2. 解决方案 :candy:](#2-解决方案-candy)
- [3. 安装和运行 :birthday:](#3-安装和运行-birthday)
- [4. 现有问题 :sandwich:](#4-现有问题-sandwich)
- [5. 使用许可 :page_facing_up:](#5-使用许可-page_facing_up)

## 1. 背景 :cookie:
多线程是操作系统的一个重要的特性，它频繁出现在各项任务和业务中，但是频繁的线程创建和销毁将带来大量的线程调度带来的时间损耗，因此出现了线程池。最简单的线程池就是创建多个工作线程，持续争抢任务队列中的任务，来异步完成提交的各项任务。

但是，最简易的线程池虽然省去了线程创建和销毁的时间代价，但是也引入了任务争抢带来的加锁解锁、等待唤醒之类的时间损耗。因此，线程池的优化也是一个十分重要的问题。

## 2. 解决方案 :candy:
本项目目前主要针对该问题实施了三种优化方式，分别如下：

- 提高线程的扇入和扇出：由于单个任务执行可能带来大量的资源争抢问题，那么我们可以考虑，每次让线程批量执行一部分任务，从而减少对任务的争抢带来的加锁解锁、等待唤醒的耗时。这样，我们可以灵活地在任务量激增的情况下将线程转换为批量执行模式，从而提高线程池的执行效率。
- 线程本地队列：在 C++11 之后，引入了 `thread_local` 线程本地变量的概念。因此，我们可以为每一个核心线程配备一个本地的任务队列缓存，其中的任务由线程池进行统一分配，防止出现任务分配不均的问题。此后，核心线程只需要访问当前的任务缓存，而不需与其他线程争抢线程池的唯一任务队列，从而尽可能减少资源争抢的耗时。
- 任务窃取：假设我们有 10 个任务，但是由于一个意外被全部分配给第一个核心线程，这样会导致线程池退化为单线程。因此，当一个线程完成本地任务缓存后，也要检查是否其他核心线程还有未完成的任务，来帮助其完成任务，使得任务执行时间得到均摊，进一步减少任务执行的耗时。

此外，我们除了使用这三种优化方案，还自行实现了自旋锁。自旋锁不会导致线程挂起或唤醒，也不会导致上下文的切换和系统调度，而是采用轮询的方式来检查是否可以上锁。这样在资源访问时间较短、冲突较少（上述三个优化方案减少冲突）的情况下，可以极大地节省由于上锁和解锁带来的时间损耗。

## 3. 安装和运行 :birthday:

本项目无需安装，只需编译运行。作者的 IDE 是 Clion，但是无论使用什么 IDE，只要在代码中引用了 `thread_pool` 头文件，都可以轻松的使用本代码。

本项目提供了测试代码 `main.cpp`，目前在 3 个核心线程的情况下执行 5m 个睡眠 1us 的任务耗时低于 14s。

## 4. 现有问题 :sandwich:
删除了网络版本的简易线程池，下一步将继续优化当前项目线程池。

## 5. 使用许可 :page_facing_up:
[GPL 2.0](./LICENSE) &copy; Xu.Cao (Steve Curcy)
